// for all the code you can refer to repo : Rock7777/beautiful-leftpad-2yhnvk

context api:

to make use of context we need to make sure 3 steps are done

1. create context - do it using React.createContext()
2. after creating context, we need to provide it with a value and for the consumer
   to consume it we need to wrap the children within the provider 
3. finally we need to import context which we provided with a value in parent component  in the consumer
   component , and we will be using useContext hook to get the value
   
   
example code:

// App.js

  import React from "react";
import "./styles.css";
import ComponentC from "./components/ComponentC";

export const UserContext = React.createContext();
export const SportsContext = React.createContext();
export default function App() {
  return (
    <div className="App">
      <UserContext.Provider value={"Rakesh"}>
        <SportsContext.Provider value={"Cricket"}>
          <ComponentC />
        </SportsContext.Provider>
      </UserContext.Provider>
    </div>
  );
}

// ComponentC.js

import ComponentE from "./ComponentE";

const ComponentC = () => {
  return (
    <div>
      <ComponentE />
    </div>
  );
};

export default ComponentC;


// ComponentE.js

import ComponentF from "./ComponentF";

const ComponentE = () => {
  return (
    <div>
      <ComponentF />
    </div>
  );
};

export default ComponentE;


import { useContext } from "react";
import { UserContext, SportsContext } from "../App";

const ComponentF = () => {
  const userName = useContext(UserContext);
  const sportsName = useContext(SportsContext);
  return (
    <div>
      <h1>ComponentF - {userName} </h1>
      <h2>Sports - {sportsName} </h2>
    </div>
  );
};

export default ComponentF;


complete this also today - 4th Nov,2025

****************************************************************************************************************************

react state management, context API, controlled/uncontrolled components, prop drilling learn abt redux state management also
 
JS types, engine used, arrow function (this binding) --> arrow functions don't create their own this
they borrow it from surrounding code --> need to check on it, 
advantage of using arrow function, 
destructuring, 
promises, 
async/await 

JS Types:

they are primitive - string,number,boolean and non-primitive data types - Object

typeof [1,2,3] --> object
typeof function(){} --> function
 
Typescript interface/type

what is event loop in JS?

JS is actually single thread event loop is a system which enables JS handle asynchronous code

first there is call stack where synchronous code gets executed , once executed it will be removed

second there is web api's which are provided by browsers which run outside call stack , 


they handle async tasks like DOM events, promises , async/await and fetch

next Promises , async/await will be put in micro task queue which has higher priority and something like setTimeout will be put in callback queue

so the process is first synchronous code gets executed then when call stack is empty it checks for tasks from callback queue if present it executes it if not it does the same
for microtaskqueue 

what is JS engine and how it works?

JS engine is a program which runs inside ur browser to read , interpret and execute JS code

so stages in tat:

1. Parsing- it builds a abstract syntax tree
2.JIT compiler and frequently used hot code will be optimized for better performance
3. finally optimized machine code which runs on CPI

JS engine manages call stack, async tasks memory allocation , garbage collection --> it dynamically frees the memory when tat particular object or variable is not used

example of JS engine is V8 which runs on chrome,edge developed by google
 
Next.js routing, data fetching, REST API overview, Get/put/post/delete/patch, Next.js backend capabilities  

JS Question - If we have A, B, C, and D operations where A,B,C depend on D. How will you fetch them? 

first fetch D using async/await and then make use of Promise.all([async A(dResult),B(dResult),C(dResult)])

Implementation:

async function D(){
const dResult = await APIcall
 return dResult
}

async function A(dResult){
// do something
}

async function B(dResult){
// do something
}

async function C(dResult){
// do something
}

async function getResults()
{
  const dResult = await D();
  const [aRes,bRes,cRes]=await Promise.all([A(dResult),B(dResult),C(dResult)])
}
getResults();

we can solve the above question with promise chaining also:

D().then(dResult => Promise.all([A(dResult),B(dResult),C(dResult)])).then(([a,b,c]) =>  console.log(a,b,c)).catch(err=> console.log(err))



*****************************************************************************************************************************



complete the below 42 programs

1. Auto Complete search
2. custom table with search,sort functionality of columns and rows
3. dropdown menu with search functionality
4. nested folder and file structure like vs code with create,rename,delete functionality of
   folders and file - akshay saini refer
5. pagination and how to handle pagination if thousands
   of data from api i.e show dots between numbers'
6. Infinite scrolling
7. comments/nested commnets or youtube comments type functionality
8. countdown timer
9. custom modal
10. multi step form
11. login otp input
12. carousel
13. progress bar with css only and with addition of js,css'
14. breadcrumbs
15. drag and drop
16. dark/light mode
17. star rating
18. search with pagination
19.  date picker
20. product filters

21. counter app with increment/decrement and reset
22. denounced input / button
23. todo app
24. accordion component
25. tabs component
26. custom hooks(input/toggle/fetch)
27. stopwatch timer
28. fetch and display api data
29. form with validation
30. useeffect cleanup demo(setTimeout/setInterval/ any event listener)
31. usereducer hook and manage state
32. HOC example
33. useCallback example
34. useMemo example
35. lazy loading example
36. pagination component
37. search filter component
38. build a calculator
39. modal component
40. auto complete drop-down
41. loader component with css only and with addition of js and css
42. error boundary example

two life cycle methods in error handling are - 

1. static getDerivedStateFromError(error)
2. componentDidCatch(error,info)

what is an ErrorBoundary?

It is nothing but a class component which implements one or two of the above mentioned error handling
life cycle methods , then the class component becomes an error boundary

static getDerivedStateFromError method is used to render fallback UI when a error is thrown in code and componentDidCatch method logs the 
error information

ErrorBoundary , they are highly useful in production because they render a fallback UI instead of crashing the entire application

but in development they show errors as many as possible , to log the error info we have life cycle method componentDidCatch(error,info)
but React in development mode however logs the info in console , this method will be helpful in production

Note: error boundaries catch error during rendering and they do not catch errors in eventhandler methods for tat we need to use regular try catch blocks only


then complete the 10 videos and code it along the way:

https://www.youtube.com/watch?v=UTky8eipUhA&list=PLlasXeu85E9cciv04MYWscodnbRFqACsH

after this : complete next js full course by code evolution which is 7 hrs long 

and then complete react native - that's it we get 30 lpa job lets go

lets check on CI/CD and AWS (today - 31st october)

AWS Code Deploy with Code Pipeline

****************************************************************
work on 4th November -

1. build a usePrevious hook showing the previous state value and current state value

usePrevious.js

import { useRef, useEffect } from "react";

const usePrevious = (value) => {
  const ref1 = useRef();
  useEffect(() => {
    ref1.current = value;
  }, [value]);
  return ref1.current;
};

export default usePrevious;

Component1.js

import { useState } from "react";
import usePrevious from "./usePrevious";

const Component1 = () => {
  const [text, setText] = useState("");
  const prevStateValue = usePrevious(text);
  return (
    <div>
      <h1>Component1</h1>
      <input
        type="text"
        onChange={(e) => setText(e.target.value)}
        value={text}
      />
      <h2>
        Value-{text} and PreviousValue - {prevStateValue}{" "}
      </h2>
    </div>
  );
};

export default Component1;

2. Error Boundary Example

  ErrorBoundary.js
  
  class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
	this.state = {
	hasError: false
  }
  }
  static getDerivedStateFromError(error) {
	return {hasError: true}
  }
  componentDidCatch(error,errorInfo) {
	console.error("Something went wrong!!",error,errorInfo)
  }
  render(){
	if(this.state.hasError) {
	return <h2>Something went wrong!!!</h2>}
  }
  return this.props.children
  }
  
  Component2.js
  
  const Component2 = ()=>
  {
	const [count,setCount] = useState(0)
	if(count === 3)
	{
	  throw new Error("count value is 3!App crashed!!")
	}
	return(
	  <button onClick={()=> setCount(count+1)>Count - {count}</button>
	)
  }
  
  finally in App.js:
  
  return(
  <div>
   <ErrorBoundary>
    <Component2/>
   </ErrorBoundary
  </div>)
  
3. build a loader component with css only


for tomorrow learn
 
1. map,reduce,filter
2. call,apply,bind
3. promises
4. async/await
5. data fetching , custom hooks , HOC
6. destructuring values examples
7. rest and spread

8. WHEN to use JSON.parse and when to use JSON.stringify

  JSON.parse - means it converts string into object - this is needed when reading data from server
  JSON.stringify - means it convert object into string - this is to send data to server


questions I need to learn today itself:
  
  first learn scss
  
  1. css modules
  2. styled components
  3. I need to learn styles in scss. what is mixin.
  4. tailwind css - I can learn later
  3. cross site scripting

  4. what is shallow copy and deep copy
     shallow copy - it copies only first level of object , nested objects within tat are still referenced
	 deep copy - it copies all the levels , it is completely independent of original
	 
	 example of shallow copy - 
	 
	 const person = {
  name: "Alice",
  address: { city: "New York", zip: 10001 }
};

// Shallow copy using spread operator
const shallowCopy = { ...person };

shallowCopy.name = "Bob"; // changes only the copy
shallowCopy.address.city = "Los Angeles"; // affects BOTH!

console.log(person.address.city); // Los angeles
	 
	 
	 example of deep copy - 
	 
	 const person = {
  name: "Alice",
  address: { city: "New York", zip: 10001 }
};

// Deep copy  (modern JS)
const deepCopy = JSON.parse(JSON.stringify(person));

deepCopy.name = "Bob";
deepCopy.address.city = "Los Angeles";

console.log(person.address.city); // "New York" âœ…


  5. build a UI where on click of button it shows progress building from 1% to 100%
  below I have something called queue progress bar - with count value set to 0
  on click of 5 times it shows 5 progress bars
  on click of 6 nothing happens initially after first one disappears only then the 6th one starts
  
  6. learn about middleware in redux - sagas and thunk and when they are used
  7. what is use of mixin in scss

  8. what is pure function in JS?

     1. no matter how many times you call the function if the same input is passed then the output should remain same
	 2. it has no side effects - what is side effect?
	 
	 example of pure function -
	 
	 function add(a,b) {
	   return a + b
	 }
	 
	 
	 add(5,3)
	 add(5,3)

// all answers for UOB client interview conducted in hcl need to add code for pagination will do tat today later
// done tat completed all answers will add complex code for useReducer later today

1.function returns an object in jest how can we write test cases in jest

Solution:


getUserData.js:

const getUserData = (id)=>
{
  if(id === 1) {
  return {userId: 1, name:"Rock1", info:"Rock1 info"}
}
else if(id === 2) {
  return {userId: 2, name:"Rock2", info:"Rock2 info"}
}
else {
  return {userId: null, name:null, info:null}
}
}

export default getUserData

getUserData.test.js

import {getUserData} from "./getUserData"

describe("getUserData",()=>
{
  it("should return correct user object userId 1",()=>
{
  const result = getUserData(1)
  expect(result).toEqual({userId: 1, name:"Rock1", info:"Rock1 info"})
});

it("should display the correct info for id 2",()=>
{
  const result = getUserData(2)
  expect(result).toEqual({userId: 2, name:"Rock2", info:"Rock2 info"});
});

it("should display the null for unspecified id",()=>
{
  const result = getUserData(3)
  expect(result).toEqual({userId: null, name:null, info:null});
});
})



if jest not installed , npm install --save-dev jest

in package.json --> "scripts" : {"test" : "jest"}

run : npm test
  

2. write code for pagination in react js and by default it should load a page and onclick of particular page it 
   has to show 5 records pertaining to tat page and it should have next and previous button 

Solution:

// added it

onLoad - it has to by default show the mentioned no.of records in tat page , by default
it should be page 1
on navigating to different page data should be loaded dynamically

// Hardcoded array of 25 fruit names
const fruits = [
    "Apple",
    "Banana",
    "Mango",
    "Orange",
    "Pineapple",
    "Grapes",
    "Watermelon",
    "Papaya",
    "Strawberry",
    "Blueberry",
    "Raspberry",
    "Blackberry",
    "Cherry",
    "Peach",
    "Pear",
    "Plum",
    "Kiwi",
    "Pomegranate",
    "Guava",
    "Lychee",
    "Apricot",
    "Cantaloupe",
    "Dragonfruit",
    "Fig",
    "Coconut"
];

console.log(fruits);

// Solution:

// Hardcoded array of 25 fruit names

import React,{useEffect,useState} from "react";

const App = () =>
{
  const fruits = [
    "Apple",
    "Banana",
    "Mango",
    "Orange",
    "Pineapple",
    "Grapes",
    "Watermelon",
    "Papaya",
    "Strawberry",
    "Blueberry",
    "Raspberry",
    "Blackberry",
    "Cherry",
    "Peach",
    "Pear",
    "Plum",
    "Kiwi",
    "Pomegranate",
    "Guava",
    "Lychee",
    "Apricot",
    "Cantaloupe",
    "Dragonfruit",
    "Fig",
    "Coconut"
];
const recordsPerPage = 5;
const numberOfPages = fruits.length / recordsPerPage 
const [currentPage,setCurrentPage] = useState(1)
const [pageItems,setPageItems] = useState([])
// indexes - 0 , 5 , 10 , 15 , 20
const handlePageChange = (pageNumber) =>
{
  if(pageNumber >=1 && pageNumber <=numberOfPages)
  {
    setCurrentPage(pageNumber)
  }
}
useEffect(()=>
{
  const initialIndex = (currentPage - 1) * recordsPerPage
  const lastIndex = initialIndex + recordsPerPage
  setPageItems(fruits.slice(initialIndex,lastIndex))
},[currentPage])
const pageNumbers = []
for(let i=1;i<=recordsPerPage;i++) {
  pageNumbers.push(i)
}
return(<div>
    {pageItems.map((page,index)=>
    {
      return (
      <li key={index}>
        {page}
      </li>)
    })}
  <button onClick={() => handlePageChange(currentPage + 1)} disabled={currentPage === recordsPerPage}>Next</button>
  <button onClick={() => handlePageChange(currentPage - 1)} 
  disabled = {currentPage === 1}>Previous</button>
  {pageNumbers.map((page,index)=>
  {
    return(
      <button onClick={()=>handlePageChange(page)}
      disabled = {currentPage === index + 1}
      key={index}>
        {page}
      </button>)
  })
  }
  </div>)
}

export default App;


3.how to reverse an array without using reverse method

Solution:

const s1 = "Rakesh earns 1cr"
const a1 = s1.split(" ")
console.log("array",a1)
let reversedArray = []
for(let i=a1.length-1;i>=0;i--)
{
    console.log(a1[i])
    reversedArray.push(a1[i])
}
const a2 = reversedArray.join(" ")
console.log("a2:",a2) // 1cr earns Rakesh


4.in typescript how do we write result of three numbers
  
Sol: function sum(num1:number,num2:number,num3:number) : number {
    return num1 + num2 + num3
}

const p2 = sum(10,3,4)
console.log("Sum:",p2)

// Output: Sum: 17

Important Note : 

In typescript we define types to function arguments or return type explicitly like above for a function



5.how to reverse words in an array from string

Sol: 

using reverse method in javascript reversing order of words

const s1 = "Rakesh earns 1cr"
const a1=s1.split(" ")
console.log("Array:",a1.reverse().join(' ')) // --> 1cr earns Rakesh
// reverse method can be used only on entire array not on 
// individual elements in ar

Imp Note: trim() method is used to remove empty spaces on both sides of the string
it can be used only on string variables or objects
 
 diff between string literal and string variable

console.log("Hello World"); // Directly used 
above hello world is string literal

// String variable
let greeting = "Hello World"; // Assigned from a literal --> string variable can have value from
literal, user input or some computation and string variable can be changed as shown below

console.log(greeting);

// Changing variable value
greeting = "Hi there!";
console.log(greeting);

// without using reverse method in javascript reversing order of words

Solution:

const s1 = "Rakesh earns 1cr"
const a1 = s1.split(" ")
console.log("array",a1)
let reversedArray = []
for(let i=a1.length-1;i>=0;i--)
{
    console.log(a1[i])
    reversedArray.push(a1[i])
}
const a2 = reversedArray.join(" ")
console.log("a2:",a2) // 1cr earns Rakesh




6.useReducer hook

Solution : 

// added it
// will add complex useCase for useReducer today on 13th nov later

it is also one of the hooks for state management along with useState hook when we have a complex state
to maintain we prefer useReducer 

below I have given a simple example lets add the complex example later

App.js

import React from 'react';
import { useState, useReducer } from 'react'

function App() {
  // const [count, setCount] = useState(0)
  const INCREMENT = "Increment"
  const reducer = (state,action) =>
  {
    switch(action.type)
    {
      case INCREMENT:
      return {count: state.count + 1}
      default:
      return state
    }
  }
  const initialState = {count : 0}
  const [state,dispatch]=useReducer(reducer,initialState)
  
  const handleIncrement = () =>
  {
    dispatch({type: INCREMENT})
  }

  return (
    <div>
      <h1>Hello, World!</h1>
      <div>
        <button onClick={handleIncrement}>
          count {state.count}
        </button>
      </div>
    </div>
  )
}

export default App


 

7.how to insert elements in between indexes of an array

Sol: basically to insert elements in between using indexes we make use of splice method
  which has three arguments first argument takes in the position where element needs to be inserted,
  next argument takes the count of number of elements to be deleted from tat position if it is 0 , then
  no element gets deleted finally last argument contains the value to be inserted.

  splice method affects original array 

  example code:

   const a1= [1,2,4,5,6]
   to insert element between 4 and 5 ,
   a1.splice(3,0,6) => this means since I want to insert an element between 4 and 5,
   the first argument is 3 indicating tat element has to be inserted at index 3 and tat element is 6 which is
   the third argument, the second argument being zero indicates tat no elements needs to be deleted

   console.log(a1) // => Output --> [1,2,4,6,5,6]

learn about splice and slice method with examples ?

8.what are pseudo elements and pseudo classes

Solution: pseudo classes help us to add style to state of an element like for example a:hover , a:visited
here : is the syntax for pseudo classes where as pseudo elements style specific part of an element

for eg:
 
.p::first-line {
	
}

it means we apply style only to the first line of paragraph element and the syntax is ::

we can combine both pseduo classes and pseudo elements


eg: p:first-child::first-line {
font-weight: bold;
}


9.what are combinators

Sol: combinators in css define the relationship b/w two or more selectors
     allowing to target and style the elements based on their position in HTML structure.

 types:
1. descendant combinator
    
   div p{
   color: green; // style all the paragraph elements which are the descendants of  div
}

2. child combinator

   div > p{
    color: blue; // style only the p elements which are direct children of div
}

3. adjacent sibling combinator

   h1 + p {
   font-weight: bold; // styles only the first p which is right after an h1 meaning 
                     // once h1 tag closes and with the same parent
}

4. general sibling combinator


   h1 ~ p{
   color: yellow; // styles all the p elments which are the next siblings of specified element
   //  and share the same parent
}

// content below from here is content of file: definite_20_questions_interview_crack_boeing_client

definite 20 questions to know to crack for boeing client

I will provide answers only for those which I am not sure of

1. what is virtual DOM and how does it differ from real DOM?

Solution: algorithm used is diffing I know the rest

2. what are React hooks? Can you explain useState and useEffect?

Solution: I know

3. explain the concept of component lifecycle in React. how is it handled
   in functional components?
Solution: I know

4.what is React context api? how does it differ from prop drilling?

Solution: Context api provides a way to share data globally across component tree I know

5. what are controlled and uncontrolled components?

Solution: Controlled components are where form data are controlled by react state
form data is handled by DOM itself - uncontrolled components

6. what are React fragments and who do we use them?

Solution: React fragments are useful when we need to group multiple elements without needing to add extra nodes to DOM.
they are useful when we need to render multiple elements without addition of extra div's or other html elements which will cause 
styling issues.

eg for fragment: return(<><h1>Hello!!</h1></>)

7. explain concept of React's key prop in lists? why is it important?

Solution: I know

8. what is difference between useMemo and useCallback?
Solution: I know

Note: 
1.in index.js this is how we import App.js

index.js:

import App from './App'
import {createRoot} from "react-dom/client"

const rootElement = document.getElementById("root")
const root = createRoot(rootElement)

root.render(<React.StrictMode><App/></React.StrictMode>)

2. what is use of strictmode and why do we need it?

Solution:  strictmode is a wrapper component which only runs in development , it doesn't affect production , it helps you write safe code.

it detects unsafe lifecycle methods like componentWillUpdate , deprecated api's like findDOMnode

9. what are higher order components?

Solution: 


10. explain error boundary?




11. what are pure components?

the components which render the same output if the state and props doesn't change , they make unnecessary re-renders not possible.
they implement shouldComponentUpdate method by default but by doing shallow comparison of state and props , only if the 
shallow comparison of state and props if there is a change then only re-render occurs which is not case with regular component.

code I am just writing the skeleton

example :

parentcomponent.js

constructor(){
this.state ={
name: 'Rock'}}

componentDidMount(){
setInterval(()=>{
this.setState({
name: ''Rock})},2000)
}

render() {
console.log('ParentComponent render')
return(
<PureComponent1 name={this.state.name}/>
<Regular Component name={this.state.name}/>
)
}

App.js

render()
{
  return(
  <ParentComponent/>
)
}

PureComponent1.js

class PureComponent1 extends PureComponent{
render() {
console.log('PureComponent render')
return(
<h1>Pure - {this.props.name}</h1>
)
}
}

RegularComponent.js

class  RegularComponent extends React.Component{
render() {
console.log('RegularComponent render')
return(
<h1>Regular - {this.props.name}</h1>
)
}
}

As u can see above the name is not changed after every 2 sec in parent component but after 2 sec
we will see in console log both stmts from parent and Regular component but from Pure as it does a shallow comparison of
props and state and sees tat there is no change and hence re-rendering will not occur

Node js definite must know 20 qns?

Very very important:

find the closest element to zero from array : a1=[-4,-2,1,4,2]

Solution:

closest element to zero means whose absolute value is smallest



const a1=[-4,-2,1,4,2,-1]
let closest = a1[0]
for(let i=0;i<a1.length;i++) {
    if(Math.abs(a1[i]) < Math.abs(closest) 
      || (Math.abs(a1[i] === Math.abs(closest) && a1[i] > closest)))
    {
        closest = a1[i]
    }
}

// Rule is if two numbers are closest to zero choose the positive one
console.log(closest)





















    

  
  
  





